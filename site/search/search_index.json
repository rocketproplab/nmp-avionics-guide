{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NMP Avionics Guide","text":"Welcome!  <p>In the Rocket Propulsion Lab New Member Project, teams are tasked with designing, fabricating, and launching a simple amateur rocket. This rocket has a simple mission profile: go as high as (reasonably and safely) possible, and recover the vehicle safely after flight.</p> <p>To measure the success in achieving the objectives of this mission profile, an NMP rocket will be equipped with a simple avionics package that can record flight data.</p>"},{"location":"#what-is-avionics-and-a-brief-history","title":"What is Avionics, and a Brief History","text":"<p>Avionics is a portmanteau of \"aviation electronics.\" It is a blanket term for any electronics that assist in controlling or operating aircraft and spacecraft. Avionics takes the form of many subfields, including guidance, navigation, and control (GNC); radio communications; pilot awareness (sensors); and more.</p> <p> </p> The V2 Guidance System (1944) used a combination of mechanical components and circuits to sense and integrate acceleration to get position and velocity. <p>The first avionics packages were electromechanical in nature. Gryoscopes were physical objects that were rotated to maintain a frame of reference, and electronic signals were analog. However, as aviation and space flight developed in parallel to the semiconductor revolution, innovations in computer hardware enabled more sophisticated digital avionics. These digital avionics, like the Apollo Flight Computer, set the stage for a variety of new mission profiles. </p> <p> </p> Margaret Hamilton, a prolific software engineer, standing next to the navigation software that she and her MIT team produced for the Apollo Guidance Computer. Predating general-purpose programming languages, the code for the computer was written entirely in assembly language. <p>Today, hobbyist rocket flight computers start at about 8 times more powerful than the Apollo flight computer while having ~=4500x less mass. Innovations in computing continue to pay dividends, with advancements in artificial intelligence setting the stage for entirely autonomous drone flights on distant worlds.</p>"},{"location":"#baseline-avionics-requirements","title":"Baseline Avionics Requirements","text":"<p>Your rocket's avionics package must perform the following functions:</p> <ul> <li>Record the maximum flight altitude.</li> <li>Save the maximum flight altitude to a storage medium so it can be read post-flight.</li> </ul> <p>As long as your avionics package can perform these tasks, feel free to go above and beyond as much as you want.</p>"},{"location":"#the-avionics-package-levels","title":"The Avionics Package Levels","text":"<p>To assist NMP teams of all skill levels, a couple guides have been prepared:</p> <ul> <li>Level 0 is targeted at teams that just want to acquire a pre-existing flight computer and not design anything on their own.</li> <li>Level 1 is oriented at teams that want to make a flight computer using an Arduino Nano and breakout boards.</li> </ul>"},{"location":"contributing/","title":"Contributing to this Guide","text":"<p>This guide lives on a public GitHub repository, allowing anyone to submit suggested changes via a Pull Request. If you think this guide can be expanded or improved in any way, feel free to contribute!</p>"},{"location":"contributing/#mkdocs","title":"MkDocs","text":"<p>This site is powered by Material MkDocs. MkDocs builds markdown files into static websites. Material MkDocs is a theme that adds additional formatting and features.</p> <p>For full documentation visit mkdocs.org or Material MkDocs.</p>"},{"location":"contributing/#building-the-site-locally","title":"Building the Site Locally","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before building, install the following software:</p> <ul> <li>Python 3.10</li> <li>Pip, the Python Package Manager</li> </ul>"},{"location":"contributing/#building-the-site","title":"Building the Site","text":"<p>While contributions can be made by directly adding and editing markdown files, it is generally nicer to continuously build the site to see how changes look to normal readers.</p> <ol> <li>Open a terminal window and navigate to the root directory of this project.</li> <li>Type <code>pip install -r requirements.txt</code> to install required dependencies.</li> <li>Type <code>mkdocs serve</code> to start a local development server.</li> </ol> <p>When ready to build the site as a static HTML website, type <code>mkdocs build</code>.</p>"},{"location":"Level0/Level00/","title":"Level 0 Guide","text":""},{"location":"Level0/Level00/#target-audience","title":"Target Audience","text":"<p>Suppose for a moment you want to avoid electronics and software all-together. Maybe you tried programming once and wrote some fine spaghetticode before deciding that programming was not for you. Maybe you burned your hand on a soldering iron and have lasting trauma. Maybe Professor Gary Gillespie gave you a professionalism infraction. It happens.</p> <p>This guide is for you.</p> <p>For those who wish to avoid designing and programming their own flight computer from Arduino and breakout board components, this guide provides a few recommendations for off-the-shelf avionics packages that can be simply purchased and flown on the rocket.</p>"},{"location":"Level0/Level00/#purchase-an-all-in-one-package","title":"Purchase an All-in-One Package","text":"<p>Luckily, the problem of finding the maximum altitude of a small rocket is a solved problem. There exist many all-in-one avionics packages that accomplish this task. This level of avionics involves just purchasing one of these solutions. </p> <p>RocketsEtc maintains a list of the notable ones here. This might be a good place to start looking.</p>"},{"location":"Level0/Level00/#my-recommendation","title":"My Recommendation","text":"<p>If you just want something that works, I have heard good things about the PerfectFlite FireFly. It has a fairly lean pricetag ($29.95) along with accessible documentation.</p> <p>The module itself can report max altitude through a pattern of LED blinks. If you get the optional field display (Additional $34.95, but can be shared across teams) then you can get additional information about the flight.</p>"},{"location":"Level0/Level00/#considerations","title":"Considerations","text":"<ul> <li>Only your have a full understanding of your specific avionics needs. Be sure to do thorough research to select the best pre-built solution for your rocket.</li> <li>Read any documentation and datasheets carefully. Different altimeters have different accuracies, operating parameters, data recording capabilities, and other features. Make sure you are covered.</li> </ul>"},{"location":"Level1/Level10/","title":"Level 1: Start Here!","text":""},{"location":"Level1/Level10/#target-audience","title":"Target Audience","text":"<p>This guide is oriented towards teams that are interested in building a flight computer from Arduino components.  Teams that undertake this level of Avionics either have some programming and/or hardware experience, or are eager to learn. In addition to delivering a flight computer, this guide will teach some of the skills used every weekend by RPL Avionics.</p> <p>The Level 1 Flight Computer achieves the minimum avionics requirements for NMP rockets outlined on the homepage. </p>"},{"location":"Level1/Level10/#hardware-requirements","title":"Hardware Requirements","text":"<p>One cannot build a flight computer without hardware! Before starting this guide, ensure that the following modules are provisioned.</p>"},{"location":"Level1/Level10/#arduino-nano","title":"Arduino Nano","text":"<p>Arduinos are single-board microcontrollers designed for rapidly iterating and prototyping electronic devices. Arduinos can be easily programmed to interact with the world via its electronic pin inputs and outputs. This guide uses the Arduino Nano, an Arduino with a smaller form-factor and leaner mass. While it has a weaker processor compared to other Arduino models, it will be more than enough for our purposes. </p> <ul> <li> Amazon Link</li> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level1/Level10/#male-to-male-usb-to-mini-usb-cable","title":"Male-to-Male USB to Mini-USB Cable","text":"<p>The Arduino Nano has a mini USB port that is used to upload code and provide power when plugged into a computer. This cable is listed here for completeness, but if you used the above purchasing link, you should not need to acquire an extra. Also, if working on a computer without a USB B port, you might want to get a wire that works.</p> <ul> <li> Amazon Link (Get Only If Needed)</li> </ul>"},{"location":"Level1/Level10/#micro-sd-card-module","title":"Micro SD Card Module","text":"<p>Arduinos are just microcontrollers; they only execute code instructions and have no way to save data permanently. An SD Card Module provides the Arduino with an interface to a permanent storage medium. This is where data will be written during flight.</p> <ul> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level1/Level10/#micro-sd-card","title":"Micro SD Card","text":"<p>An SD Card Module is no use without an SD Card! While this guide provides a suggestion for completeness, any SDHC SD Card will work.</p> <p>Only SDHC Micro-SD Cards are Supported!</p> <p>There are two types of SD cards on the market. SDHC cards have 32 GB or less of storage, whereas SDXC cards can have more than 32 GB of storage. The built-in Arduino SD Card library can only handle SDHC cards. If purchasing a different Micro SD card, be sure to look for the SDHC logo.</p> <ul> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level1/Level10/#micro-sd-card-adapter","title":"Micro SD Card Adapter","text":"<p>This allows a micro-sd card to be inserted into a laptop or other SD card reading peripheral. If your team already has one of these, or some other means of connecting the SD card to a computer, then getting another is not required.</p> <ul> <li> Amazon Link</li> </ul>"},{"location":"Level1/Level10/#bmp-280","title":"BMP 280","text":"<p>This is a temperature and pressure sensor. Because air pressure is related to altitude, we can use this sensor as an altimeter. Per the spec sheet, the sensor provides an accuracy for altitude of (+/-) 1 meter, but your mileage may vary. Tl;dr: It's good enough for what we need it to do.</p> <ul> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level1/Level10/#9v-battery-clip","title":"9V Battery Clip","text":"<p>The Arduino Nano can receive power from a computer via a mini-USB cable. However, this power supply does not exactly fit onto a rocket. A 9-volt battery clip will be soldered to the Arduino to provide plenty of power to the Arduino during flight. Battery not included; be sure to pick one up yourself.</p> <ul> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level1/Level10/#breadboard","title":"Breadboard","text":"<p>Breadboards are boards where electronic circuits can be temporarily assembled for prototyping and testing. While not required, it is strongly recommended for your team to acquire a breadboard.</p> <ul> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level1/Level10/#jumper-cables","title":"Jumper Cables","text":"<p>Jumper cables interface with IO pins, allowing multiple boards and breadboards to be connected together easily. Like other cables, jumper cables come in male and female form-factors. It is always good to have a variety of jumper cables on hand.</p> <ul> <li> Amazon Link</li> </ul>"},{"location":"Level1/Level10/#i-found-a-cheaper-board-reputable-vendors-vs-knockoffs","title":"\"I Found a Cheaper Board:\" Reputable Vendors vs. Knockoffs","text":"<p>When provisioning Arduino modules, one can find two broad categories of modules. Reputable vendors like Adafruit sell modules at moderate prices, whereas Knockoff vendors sell boards that look similar to those of reputable vendors but at much lower prices.</p> <p>Reputable vendors tend to be the first ones to design and manufacture modules. They are the primary folks behind the code libraries that complement the hardware. These boards usually come with higher price tags and better documentation and support.</p> <p>Knockoff vendors make their own versions of the modules made by reputable vendors. They take advantage of bulk purchasing and the existing libraries made by the reputable vendor to keep costs down. However, there is no gurantee that knockoff boards will work with existing libraries. Sometimes, knockoff boards require some debugging and \"motivation\" to become functional. Moreover, knockoff boards have a higher risk of being defective, and knockoff vendors will generally not provide replacements for defective boards.</p> <p>In this guide, we link several boards made by knockoff vendors. Luckily, the legwork has been done; these guides should cover any gotchas and obtuse quirks of these knockoff boards.</p> <p>Just keep these ideas in mind if shopping for additional boards or cheaper versions of the boards listed in this guide.</p>"},{"location":"Level1/Level11/","title":"Setting up the Software","text":"<p>You will need two programs for this level of Avionics:</p> <ul> <li>The Arduino IDE is used for writing code, managing external libraries, and uploading programs to the Arduino Nano.</li> <li>The SD Assocation Formatting Utility is used to format our MicroSD card to ensure its file system is configured in a way that is compatible with Arduino.</li> </ul>"},{"location":"Level1/Level11/#arduino-ide","title":"Arduino IDE","text":"<p>You can get the Arduino IDE (Integrated Development Environment) here. Install it like any other program before continuing.</p>"},{"location":"Level1/Level11/#sd-assocation-formatting-utility","title":"SD Assocation Formatting Utility","text":"<p>You can get the SD Assocation Formatting Utility here. Install it like any other program before continuing.</p>"},{"location":"Level1/Level11/#reboot-your-computer","title":"Reboot Your Computer","text":"<p>It is always a good idea to reboot your computer once large development programs are installed.</p>"},{"location":"Level1/Level12/","title":"Arduino \"Hello, World!\"","text":"<p>In this chapter, we will ensure that our Arduino Nano is ready for both hardware and software development.</p>"},{"location":"Level1/Level12/#mount-arduino-to-breadboard","title":"Mount Arduino to Breadboard","text":"<p>Before we write any code, let's mount our Arduino to our breadboard. This does not do anything immediate, but it prepares our Arduino for prototyping with wires later.</p> <p>The following gif demonstrates the mounting process. Mount the Arduino such that its D13 pin is on row 1 of the breadboard.</p> <p></p> <p>What this effectively does is expand the number of connections for each Arduino pin. On the central part of the breadboard, each numbered row is connected together. Later, this will allow us to easily connect modules together by plugging jumper cables into the breadboard. </p> <p>Why not connect the jumper cables directly? This is a valid course of action, but the breadboard makes it easier to see what is going on at a quick glance. Additionally, a breadboard allows us to connect multiple modules to single pins, which will be important for later parts of this guide.</p>"},{"location":"Level1/Level12/#plug-arduino-into-computer","title":"Plug Arduino into Computer","text":"<p>Now, using the mini-USB cable, plug the Arduino into your development laptop. A red light labelled POW should turn on when this happens. If the POW light does not turn on, the board is possibly defective.</p> <p></p>"},{"location":"Level1/Level12/#lets-write-some-code","title":"Let's Write some Code!","text":"<p>Let's write our first Arduino Code. Open the Arduino IDE for the first time.</p> <p>The Arduino Editor should populate your code file with the following code.</p> Empty Arduino Project<pre><code>void setup() {\n// put your setup code here, to run once:\n\n}\n\nvoid loop() {\n// put your main code here, to run repeatedly:\n\n}\n</code></pre> <p>This code has two functions, <code>setup</code> and <code>loop</code>. The <code>setup</code> function is executed only once, right when the Arduino microcontroller first starts up. The <code>loop</code> function will execute all of the code inside it, and upon reaching the end of the function, it will go back to the beginning and execute again.</p> <p>In general, <code>setup</code> is used to initialize any libraries, establish communications with other modules, and take any actions that set the stage for regular operation. The <code>loop</code> function is where the magic happens; this is where you will be reading sensors, saving data to the SD card, and more.</p> <p>Arduino Code is C++</p> <p>While the file extension for Arduino \"sketch\" files are <code>.ino</code>, Arduino code is fundamentally C++ code. Arduino differentiates itself from C++ for two reasons:</p> <ol> <li>Arduino does provide a bunch of built-in functions that makes writing Arduino code much easier than C++. In other words, Arduino provides you with some training wheels.  </li> <li>C++ sounds scary and terrifying, so Arduino tries to distance itself as much as possible so that beginners are not terrified.</li> </ol> <p>For beginners: if you stick to just what Arduino provides you, programming Arduino should not be that different from what you may have seen in your undergraduate courses.</p> <p>For POWER USERS: because Arduino code is C++, Arduino code can do anything C++ can do. So if you are confident enough to use <code>malloc</code> and <code>free</code>, define custom objects, and other magic, knock yourself out. Just aviod the common embedded systems programming pitfalls (to be written). </p>"},{"location":"Level1/Level12/#hello-arduino","title":"Hello, Arduino!","text":"<p>It is computer science tradition that one's first program be a program that prints \"Hello, World\" to the output console. But what if your environment does not have an output console?</p> <p>One thing that must be established is that Arduinos are very simple computers. They are so simple, in fact, that there is no onboard console to print to. If we want to print a message, we will need to print the message elsewhere. </p> <p>Assuming you followed the steps above, you luckily have connected your Arduino to a highly advanced computer that does have an output console. To print messages in Arduino, we must send the messages from the Arduino to your computer.</p> <p>We do this via serial, an inter-device communication protocol. USB really stands for Universal Serial Bus, which both delivers power to the Arduino and gives us a serial connection over which we can communicate. The built-in Arduino <code>Serial</code> library provides us with the communications interface. </p> <p>To communicate over serial, we must first setup the connection using the <code>Serial.begin(9600)</code> function. Put this in <code>setup</code> like so:</p> Setting up the Serial Connection<pre><code>void setup() {\n// put your setup code here, to run once:\nSerial.begin(9600);\n}\n\nvoid loop() {\n// put your main code here, to run repeatedly:\n\n}\n</code></pre> <p>With our connection set up at <code>setup</code>, our connection is ready for communication. Let's write two <code>println</code> statements, one in <code>setup</code> and one in <code>loop</code>:</p> Hello, Arduino! Program<pre><code>void setup() {\n// put your setup code here, to run once:\nSerial.begin(9600);\nSerial.println(\"Hello, Arduino! I am setup!\");\n}\n\nvoid loop() {\n// put your main code here, to run repeatedly:\nSerial.println(\"Hello, Arduino! I am looping!\");\n}\n</code></pre> <p>Our first program is ready for upload!</p>"},{"location":"Level1/Level12/#compile-and-upload-the-program","title":"Compile and Upload the Program","text":"<p>To upload the program, we must first select the Arduino board to which we will upload. At the top of the Arduino IDE, there is a dropdown menu. With your Arduino Nano plugged in, click the dropdown menu.</p> <p>If there is a menu item for an Arduino Nano, great! We have no extra setup steps.</p> <p>If there is a menu item that says \"Unknown,\" then we have a knockoff Arduino Nano and we will need to take a few extra steps. Click unknown. A menu will a search bar will display. Type <code>nano</code> into the search bar and select the <code>Arduino Nano</code> option. The below gif shows this process.</p> <p></p> <p>At this point, we are good to upload! Click the arrow at the top of the screen to upload. When you do, an output window will display at the bottom of the screen. This is the compilation output window, and it looks something like the following when code is compiled successfully:</p> Compilation Output<pre><code>Sketch uses 1558 bytes (5%) of program storage space. Maximum is 30720 bytes.\nGlobal variables use 246 bytes (12%) of dynamic memory, leaving 1802 bytes for local variables. Maximum is 2048 bytes.\n</code></pre> <p>What does this mean? Arduinos have two areas of memory. During compilation, your Arduino code is compiled, or converted, into machine instructions the Arduino can understand and operate upon. Program storage space is where these literal assembly instructions are stored. The longer and more complex your program is, the more assembly instructions will be required to represent it. Arduino Nanos only have ~=30 kilobytes of program storage space. This doesn't sound like a lot in the era of terabyte SSDs, but it should be more than enough for most of our purposes.</p> <p>The other area of memory is dynamic memory. This is where data inside your variables is stored. (For power users, this area of memory represents both the stack and the heap). We see that global variables take up some of this storage. The remaining space is used by local variables during function calls (and, for power users: if you <code>malloc</code> for heap space).</p>"},{"location":"Level1/Level12/#using-the-serial-monitor","title":"Using the Serial Monitor","text":"<p>Our program has been compiled and uploaded. Why aren't we seeing anything? Is our program not working?</p> <p>Right now, our program establishes a serial connection with your computer and begins transmitting instructions. If we look at our physical Arduino Nano, we can see that two lights are now on.</p> <p></p> <p>One light, POW, is for power. The other, TX, stands for \"serial transmission.\" It turns on whenever data is being transmitted over the serial connection. Our program is working!</p> <p>In order to read the transmitted data, we must open the Arduino's Serial Monitor. This is a utility that dumps the serial output from the Arduino into an output console. To open it, navigate to the top of the Arduino IDE &gt; Tools &gt; Serial Monitor. You can also open it with the Ctrl+Shift+M shortcut.</p> <p></p> <p>Not Seeing Anything? Check the Baud Rate!</p> <p>Sometimes, if you open the Serial Monitor, you may see nothing. You might also see incomprehensible garbage. If this happens, the first thing to check is the baud rate. The baud rate of a serial connection is the amount of bits it sends per second. If the sender and receiver disagree on the baud rate, then messages will be decoded incorrectly. </p> <p>You may have also noticed that we passed 9600 as a parameter to the <code>Serial.begin(...)</code> function. This is what sets the sender's baud rate. Make sure this number matches the Serial Monitor's baud rate.</p> <p>We should see the text <code>Hello, Arduino! I am setup!</code> printed once, and then <code>Hello, Arduino! I am looping!</code> printing over and over again. Take a moment to reflect and see how this behavior matches the written code. Also, congratulations! You have just written your first Arduino program!</p> <p>Opening the Serial Monitor Resets the Arduino</p> <p>If you opened and closed the Serial Monitor multiple times, you may have noticed that the message <code>Hello, Arduino! I am setup!</code> always prints when the Serial Monitor is opened. This is a quirk of Arduino -- opening a serial connection from a computer will always reset the Arduino. Keep this in mind when debugging in the future.</p>"},{"location":"Level1/Level13/","title":"\"Some Assembly Required\"","text":"<p>This chapter discusses soldering tips. If your modules came pre-assembled, this section can be skipped.</p>"},{"location":"Level1/Level13/#what-is-soldering","title":"What is Soldering?","text":"<p>You may have noticed that some of your Arduino modules come with their headers attached...</p> <p></p> <p>...while others do not come with headers attached.</p> <p></p> <p>The first module is said to have headers that are soldered. Soldering is a manufacturing process that involves fusing metal objects together via the application of molten metal. </p> <p>As we are using the modules on a breadboard, it is rather inconvenient that the headers for some of our modules are not attached. The reason that manufacturers leave them off is to provide maximum flexibility for customers. When the headers are not attached, we are free to pick the best headers to attach - whether straight or angled. We might also want to just solder the module to wires directly.</p> <p>In our case though, we want to use straight headers so that the modules fit onto the breadboard.</p>"},{"location":"Level1/Level13/#equipment-for-soldering","title":"Equipment for Soldering","text":"<p>Soldering requires these tools:</p> <ul> <li>A soldering iron is a tipped tool that gets hot enough to melt solder.</li> <li>Solder is a conductive metal alloy with a low melting point.</li> <li>Because soldering involves melting metal, it is unwise to solder in an environment that is not well-ventilated. A fume absorber or fume extractor uses a fan to blow these fumes into a filter so that they are not inhaled.  </li> </ul> <p>If you need to solder electronic components, consider going to the EnVision Maker Space on campus. It has all of the above equipment available and free to use for UCSD students.</p>"},{"location":"Level1/Level13/#how-to-solder","title":"How to Solder","text":"<p>This video provides a quick guide to soldering.</p> <p>Like many fine motor skills, no amount of reading or video-watching will improve your abilities more than just a few minutes of practice. So go out there and try it!</p>"},{"location":"Level1/Level13/#avoid-too-much-solder","title":"Avoid Too Much Solder","text":"<p>Apply enough solder to form the joint, but no more. If there is too much solder, it can form a short that will prevent the component from working. See the below image.</p> <p></p> <p>The two left joints are correctly soldered. The right two joints are shorted together.</p>"},{"location":"Level1/Level14/","title":"The Micro SD Card Module","text":"<p>In this chapter, we will prepare the SD card for use with Arduino and integrate the SD Card Module.</p>"},{"location":"Level1/Level14/#formatting-the-micro-sd-card","title":"Formatting the Micro SD Card","text":"<p>Before we can do anything with the hardware, let's make sure our storage medium is ready for use.</p>"},{"location":"Level1/Level14/#why-the-sd-association-formatting-utility","title":"Why the SD Association Formatting Utility?","text":"<p>At the lowest level, storage devices like hard drives, SD cards, and flash drives provide a long array of memory addresses where bytes can be stored. However, at a high level, we like to think of data storage in a more hierarchical way where we store files in folders. Formatting a storage device is the process of preparing a storage device such that it is split into regions that help facilitate this higher-level organization method.</p> <p>In a previous chapter, we installed the SD Card Association Formatting Utility. This software </p> <p>Why can't we use Windows or Mac's built-in SD formatting utilities? Arduinos are simple computers, so they cannot handle complex storage formats. Windows and Mac OS tend to ship with formatting utilities that create complex nonstandardized formats. These formats are objectively better in most cases, but they require actual computers to handle the many edge cases that come with the more complex formatting. On the other hand, the SD Association's utility deploys a standardized and simple format to the SD Card that only requires simple logic to read. The Arduino IDE ships with an SD Card library that is built to interface with this simple format. </p>"},{"location":"Level1/Level14/#formatting-using-the-utility","title":"Formatting using the Utility","text":"<p>To format the SD card, plug the SD card into your computer.</p> <p>Vendors like SanDisk include a bunch of undesired applications and files on new SD cards. Just delete everything in the SD card. </p> <p>Open the utility. Then, select the drive and hit format.</p> <p></p> <p>Be sure to provide a name for your volume.</p> <p>The SD card will not format correctly without a name for the volume.</p> <p>Doesn't work the first time? Try disabling quick format in options.</p> <p>I have had mixed results with formatting brand new SD cards with the quick format option. If it does not work the first time, be sure to disable this by clicking the options button in the utility.</p>"},{"location":"Level1/Level14/#mounting-the-micro-sd-card-module","title":"Mounting the Micro SD Card Module","text":"<p>Because the SD Card Module comes with bent headers, mounting it to the breadboard requires some creativity. Mounting card on breadboard rows 25-30 oriented vertically seems to work best as it allows the board to rest in the well of the breadboard.</p> <p></p>"},{"location":"Level1/Level14/#wiring-the-sd-card-module","title":"Wiring the SD Card Module","text":"<p>Unplug the Arduino before Wiring</p> <p>Unplugging the Arduino during this step will reduce the risk of accidentally frying components when wiring.</p> <p>The SD Card Module has 6 pins. Wire them as directed by the table below. The breadboard rows may differ if you placed it in a different location.</p> MicroSD Pin Row Pin Purpose Connect to Arduino Pin GND 25 Ground; current flows out of here to complete the circuit. Any free GND VCC 26 Provides 5V of power into the module. 5V MISO 27 \"Master In Slave Out;\" Wire for data sent FROM SD Card module TO the Arduino. D12 MOSI 28 \"Master Out Slave In;\" Wire for data sent FROM Arduino TO the SD Card module. D11 SCK 29 \"Serial Clock,\" a repeating signal used to synchronize communications D13 CS 30 \"Chip Select,\" used by the Arduino to differentiate multiple SPI modules  during initialization. D10 <p>The following images demonstrate a properly wired SD Card module:</p> <p></p> <p></p>"},{"location":"Level1/Level14/#inserting-the-sd-card-into-the-module","title":"Inserting the SD Card into the Module","text":"<p>With the module wired correctly, it is now time to insert the SD card.</p> <p>The SD Card should click in.</p> <p>The click will feel very tactile and satisfying. Please avoid the temptation to repeat this process for more times than is necessary as it causes wear to the module.</p> <p></p>"},{"location":"Level1/Level14/#testing-the-sd-card-module","title":"Testing the SD Card Module","text":"<p>To test if your SD Card Module is wired properly, you can use the built-in SD Card example sketch.</p> <p>Double-check your Wiring before Powering Up</p> <p>While the SD Module should have a voltage regulator to prevent you from accidentially frying it, it is still a good idea to double-check wiring before turning a device on.</p> <p>In your Arduino IDE, navigate to File &gt; Examples &gt; SD &gt; CardInfo. This will open the example CardInfo sketch. Then, change the <code>chipSelect</code> constant variable to <code>10</code> to reflect our wiring job. For me, it was on line 36. Probably Line 36 of SD Example as is.<pre><code>const int chipSelect = 4;\n</code></pre> Probably Line 36 changed to 10<pre><code>const int chipSelect = 10;\n</code></pre></p> <p>Then, upload and run. Then, open the Serial Monitor. If your SD Module is wired correctly, and your micro SD card was formatted correctly, you should get filesystem info like what is shown below. The below dump is for a 32 GB SDHC card.</p> Sample Filesystem Info when Wired + Formatted Correctly<pre><code>20:50:06.671 -&gt; Initializing SD card...Wiring is correct and a card is present.\n20:50:07.083 -&gt; \n20:50:07.083 -&gt; Card type:         SDHC\n20:50:07.117 -&gt; Clusters:          973200\n20:50:07.150 -&gt; Blocks x Cluster:  64\n20:50:07.150 -&gt; Total Blocks:      62284800\n20:50:07.183 -&gt; \n20:50:07.183 -&gt; Volume type is:    FAT32\n20:50:07.216 -&gt; Volume size (Kb):  31142400\n20:50:07.250 -&gt; Volume size (Mb):  30412\n20:50:07.283 -&gt; Volume size (Gb):  29.70\n20:50:07.316 -&gt;\n</code></pre>"},{"location":"Level1/Level14/#importing-the-sd-card-library-in-your-own-files","title":"Importing the SD Card Library in Your Own Files","text":"<p>The SD Card Library ships with the Arduino IDE, so no complex installation is necessary. Just add the <code>#include &lt;SD.h&gt;</code> directive to the top of your code file.</p> <p>The following built-in example provides a good idea on how to utilize the library.</p> SD Card Library Example<pre><code>/*\n  SD card read/write\n\n  created   Nov 2010\n  by David A. Mellis\n  modified 9 Apr 2012\n  by Tom Igoe\n\n  This example code is in the public domain.\n\n*/\n\n#include &lt;SD.h&gt;\n\nFile myFile;\n\nvoid setup() {\n// Open serial communications and wait for port to open:\nSerial.begin(9600);\nwhile (!Serial) {\n; // wait for serial port to connect. Needed for native USB port only\n}\n\n\nSerial.print(\"Initializing SD card...\");\n\nif (!SD.begin(10)) {\nSerial.println(\"initialization failed!\");\nwhile (1);\n}\nSerial.println(\"initialization done.\");\n\n// open the file. note that only one file can be open at a time,\n// so you have to close this one before opening another.\nmyFile = SD.open(\"test.txt\", FILE_WRITE);\n\n// if the file opened okay, write to it:\nif (myFile) {\nSerial.print(\"Writing to test.txt...\");\nmyFile.println(\"testing 1, 2, 3.\");\n// close the file:\nmyFile.close();\nSerial.println(\"done.\");\n} else {\n// if the file didn't open, print an error:\nSerial.println(\"error opening test.txt\");\n}\n\n// re-open the file for reading:\nmyFile = SD.open(\"test.txt\");\nif (myFile) {\nSerial.println(\"test.txt:\");\n\n// read from the file until there's nothing else in it:\nwhile (myFile.available()) {\nSerial.write(myFile.read());\n}\n// close the file:\nmyFile.close();\n} else {\n// if the file didn't open, print an error:\nSerial.println(\"error opening test.txt\");\n}\n}\n\nvoid loop() {\n// nothing happens after setup\n}\n</code></pre>"},{"location":"Level1/Level15/","title":"The Altimeter Module (BMP 280)","text":"<p>In this chapter, we will integrate the BMP 280 module into the flight computer.</p>"},{"location":"Level1/Level15/#about-the-module","title":"About the Module","text":"<p>The BMP280 module integrates a pressure sensor and temperature sensor onto a single chip. Because air pressure can be related closely to altitude, this module can function as an altimeter.</p>"},{"location":"Level1/Level15/#mounting-the-altimeter","title":"Mounting the Altimeter","text":"<p>I mounted the altimeter on the breadboard between the Arduino and the SD Card module. Ensure that the pins of the BMP280 do not share any rows with the SD Card Module. If this occurs, signals intended for one module will be sent to both, causing undefined behavior.</p> <p></p>"},{"location":"Level1/Level15/#protocols-spi-and-i2c","title":"Protocols, SPI, and I2C","text":"<p>A protocol is an agreed-upon set of rules to dictate how information is passed in a system. A protocol allows two parties to know exactly how to transmit their messages such that they can be interpreted by the receiver.</p> <p>There are two major protocols for communications between electronic modules: SPI, or Serial Port Interface, and I2C, or Inter-Integrated Circuit. These protocols describe how data is encoded and decoded into electronic signals that can be transmitted over wires. Each protocol has its advantages and disadvantages, but for our purposes, we can summarize the pros and cons as follows:</p> <ul> <li>SPI tends to be faster than I2C</li> <li>SPI requires more wires than I2C</li> <li>I2C uses addresses to differentiate different modules. I2C devices only require two wires for communication, and multiple I2C modules can be \"chained\" on a single pair of wires.</li> </ul> <p>The specific BMP280 module supports both I2C and SPI, but we will be using I2C as it is the default and it will make it easier to add additional modules if that interests you.</p>"},{"location":"Level1/Level15/#wiring-the-module","title":"Wiring the Module","text":"<p>FEED THIS MODULE 3.3 VOLTS, NOT 5 VOLTS</p> <p>Unlike the SD Card Module, this module does not have a voltage regulator. The module is rated for 3.3 volts. Feeding the module 5 volts WILL fry it. FEED IT 3.3 VOLTS!!!</p> <p>The BMP20 Card Module has 6 pins. This module can operate using either software SPI or I2C. As we are using I2C, we will only use 4 of the 6 pins. Wire them as directed by the table below.</p> BMP280 Pin Row Pin Purpose Connect to Arduino Pin VCC 17 Provides 3.3V of power to this module. 3.3V (IMPORTANT) GND 18 Ground; current flows out  of here to complete the  circuit. Any GND SCL 19 \"Serial Clock;\" a repeating  signal used to synchronize communications A5 SDA 20 \"Serial Data;\" transmits data from module to Arduino A4 CSB 21 \"Chip Select,\" used by the Arduino to differentiate multiple SPI modules during initialization. Do not wire; treating this as an I2C device. SDO 22 \"Serial Data Out;\" transmits data from module to Arduino Do not wire; treating this as an I2C device. <p>The following images demonstrate functioning wiring:</p> <p></p> <p></p> <p></p>"},{"location":"Level1/Level15/#finding-the-i2c-address","title":"Finding the I2C Address","text":"<p>Check your Wiring before Power Up</p> <p>Once again: this module does not have a voltage regulator. The module is rated for 3.3 volts. Feeding the module 5 volts WILL fry it. FEED IT 3.3 VOLTS!!! Incorrect wiring for other pins could also potentially fry the board. Double check, DO NOT BE LAZY!!!</p> <p>I2C modules are given unique addresses to differentiate them. Typically, the manufacturer assigns this address arbitrarily and writes the accompanying code library to use that address as the default address. As we got a knockoff board, it is likely that the address of the module is different to that of the library's default address. Thus, in order to communicate with our BMP280, we will need it know its I2C address. </p> <p>There are two ways to find the address. The first is looking for the module's datasheet. These can be unwieldy to read for beginners, so we will instead find the address using an example Arduino sketch.</p> <p>Open the Arduino IDE. Then, navigate to File &gt; Examples &gt; Wire &gt; i2c_scanner. This example code iterates through every possible I2C address and outputs any detected modules to the Serial Monitor. Because we only have one I2C module wired up, (the SD card module is SPI) the one module we detect is our BMP280. </p> <p>Upload the code to your Arduino Nano and open the Serial Monitor. If you wired the module correctly, you should see an output like the following:</p> I2C Scanner Output<pre><code>22:02:02.103 -&gt; I2C Scanner\n22:02:02.103 -&gt; Scanning...\n22:02:02.103 -&gt; I2C device found at address 0x76  !\n22:02:02.148 -&gt; done\n</code></pre> <p>This tells us the I2C address for our BMP module is 0x76. The '0x' denotes a hexadecimal number; we can represent this number in decimal as 118. Yours may be different. Just keep this value somewhere handy for the next sections.</p>"},{"location":"Level1/Level15/#the-library","title":"The Library","text":"<p>The genuine Adafruit Bmp280 library should be compatible with our Bmp280 module. Unlike the SD Card Module, the Arduino IDE does not come with this library. We can install it via two methods:</p> <ul> <li>We could install manually by downloading the ZIP from the Github page and placing it in the correct directory. (There is a time a place for this, but no thanks.)</li> <li>Install via the Arduino Library Manager (Yeah, this one.)</li> </ul> <p>To open the Arduino Library Manager, click the books icon on the left-hand side of the screen. Or, use the Ctrl+Shift+I keyboard shortcut. Then, type <code>adafruit bmp280</code> into the search bar -- it should be the first result. To install the library, hover your mouse over the library and click install. When prompted to install dependencies for the library, click \"install all.\" Once installed, restart your Arduino IDE. The following gif demonstrates this workflow:</p> <p></p>"},{"location":"Level1/Level15/#testing-the-module","title":"Testing the Module","text":"<p>We will test this module using yet another example sketch. The folks at Adafruit provide us with some examples to see how to use the library. In the Arduino IDE, navigate to File &gt; Examples &gt; Adafruit Bmp280 Library &gt; bmp280test.</p> <p>If we upload and run this example without changing it, we will get the following output from the Serial Monitor:</p> Unmodified Bmp280 Example Output<pre><code>02:46:46.040 -&gt; BMP280 test\n02:46:46.040 -&gt; Could not find a valid BMP280 sensor, check wiring or try a different address!\n02:46:46.105 -&gt; SensorID was: 0x0\n02:46:46.139 -&gt;         ID of 0xFF probably means a bad address, a BMP 180 or BMP 085\n02:46:46.206 -&gt;    ID of 0x56-0x58 represents a BMP 280,\n02:46:46.239 -&gt;         ID of 0x60 represents a BME 280.\n02:46:46.306 -&gt;         ID of 0x61 represents a BME 680.\n</code></pre> <p>This occurs because the library is trying to use the default address that Adafruit assigns to their genuine modules. Luckily, the Adafruit library provides a way to override this address. We're looking for the line <code>bmp.begin()</code>. This function initializes the connection between the Arduino and the Bmp280. It has an undocumented overload that allows us to pass in an address directly.</p> <p>Change the line <code>bmp.begin()</code> (for me, it was on line 37) to <code>bmp.begin(&lt;I2C ADDRESS YOU FOUND IN THE \"Finding the I2C Address\" SECTION&gt;)</code> (for me, it would be <code>bmp.begin(0x76)</code>). Then, compile and upload.</p> <p>The Serial Monitor should now display approximate temperature and altitude data. Awesome!</p> Functioning Bmp280 Output<pre><code>02:55:10.901 -&gt; BMP280 test\n02:55:13.047 -&gt; Temperature = 19.90 *C\n02:55:13.047 -&gt; Pressure = 100500.05 Pa\n02:55:13.081 -&gt; Approx altitude = 68.91 m\n02:55:13.081 -&gt; \n02:55:15.046 -&gt; Temperature = 19.90 *C\n02:55:15.046 -&gt; Pressure = 100501.29 Pa\n02:55:15.078 -&gt; Approx altitude = 68.81 m\n</code></pre>"},{"location":"Level1/Level16/","title":"Making the Flight Computer","text":"<p>Now that we have set up the hardware for the flight computer and installed all of the necessary libraries, we can write the software.</p> <p>This will be left as an exercise for the reader. However, if enough groups have difficulty, feel free to ping Owen Bartolf on Discord and he will make an example flight computer sketch or flesh out this section in much greater detail.</p>"},{"location":"Level1/Level16/#considerations","title":"Considerations","text":"<ul> <li>To include the SD and BMP280 libraries in a new sketch, navigate to Sketch &gt; Include Library. This will set up the <code>#include</code> directives for you.</li> <li>The BMP280 and SD libraries have great examples. They can be accessed by navigating to File &gt; Examples.</li> <li>When writing the flight computer, consider writing to a new file every time the flight computer turns on. This prevents data loss during flight if the flight computer momentarily powers down due to power fluctations.</li> </ul>"},{"location":"Level2/Level20/","title":"Level 2: Above and Beyond","text":""},{"location":"Level2/Level20/#target-audience","title":"Target Audience","text":"<p>Do you like electronics? Are you an all-code, all-the-time kind of person? Do you want to make something truly nuts?</p> <p>I like you.</p> <p>Welcome to Level 2. This is a blanket level that basically means \"do everythig in Level 1, plus whatever you desire.\" For the sake of completeness, I will include a single suggestion of where to go from Level 1.</p>"},{"location":"Level2/Level20/#prerequisites","title":"Prerequisites","text":"<p>Level 1 defines the minimum viable custom flight computer. Finish that before going above and beyond.</p>"},{"location":"Level2/Level20/#hardware-requirements","title":"Hardware Requirements","text":"<p>Really, it is up to you to choose what additional modules you want to select. I have one suggestion, however.</p>"},{"location":"Level2/Level20/#mpu-6050","title":"MPU 6050","text":"<p>The MPU6050 is a six-axis accelerometer and gyroscope. This module can be used to measure the acceleration and orientation of the rocket as it flies. If enough people integrate this module onto their rockets, Owen Bartolf might write a program to visualize the trajectory of your rockets in 3D (if you ask nicely). </p> <ul> <li> Cheaper in Bulk; Coordinate with Multiple Teams</li> </ul>"},{"location":"Level2/Level20/#anything-you-imagine","title":"Anything you imagine!","text":"<p>Go nuts.</p>"},{"location":"Level2/Level21/","title":"MPU 6050","text":"<p>I'm gonna be honest I am going to leave the setup guide for this module for next week.</p>"}]}